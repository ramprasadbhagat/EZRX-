// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AuthException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthExceptionCopyWith<$Res> {
  factory $AuthExceptionCopyWith(
          AuthException value, $Res Function(AuthException) then) =
      _$AuthExceptionCopyWithImpl<$Res, AuthException>;
}

/// @nodoc
class _$AuthExceptionCopyWithImpl<$Res, $Val extends AuthException>
    implements $AuthExceptionCopyWith<$Res> {
  _$AuthExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InvalidEmailAndPasswordCombinationImplCopyWith<$Res> {
  factory _$$InvalidEmailAndPasswordCombinationImplCopyWith(
          _$InvalidEmailAndPasswordCombinationImpl value,
          $Res Function(_$InvalidEmailAndPasswordCombinationImpl) then) =
      __$$InvalidEmailAndPasswordCombinationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidEmailAndPasswordCombinationImplCopyWithImpl<$Res>
    extends _$AuthExceptionCopyWithImpl<$Res,
        _$InvalidEmailAndPasswordCombinationImpl>
    implements _$$InvalidEmailAndPasswordCombinationImplCopyWith<$Res> {
  __$$InvalidEmailAndPasswordCombinationImplCopyWithImpl(
      _$InvalidEmailAndPasswordCombinationImpl _value,
      $Res Function(_$InvalidEmailAndPasswordCombinationImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidEmailAndPasswordCombinationImpl
    implements _InvalidEmailAndPasswordCombination {
  const _$InvalidEmailAndPasswordCombinationImpl();

  @override
  String toString() {
    return 'AuthException.invalidEmailAndPasswordCombination()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmailAndPasswordCombinationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) {
    return invalidEmailAndPasswordCombination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) {
    return invalidEmailAndPasswordCombination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) {
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) {
    return invalidEmailAndPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) {
    return invalidEmailAndPasswordCombination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) {
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAndPasswordCombination implements AuthException {
  const factory _InvalidEmailAndPasswordCombination() =
      _$InvalidEmailAndPasswordCombinationImpl;
}

/// @nodoc
abstract class _$$AccountLockedImplCopyWith<$Res> {
  factory _$$AccountLockedImplCopyWith(
          _$AccountLockedImpl value, $Res Function(_$AccountLockedImpl) then) =
      __$$AccountLockedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountLockedImplCopyWithImpl<$Res>
    extends _$AuthExceptionCopyWithImpl<$Res, _$AccountLockedImpl>
    implements _$$AccountLockedImplCopyWith<$Res> {
  __$$AccountLockedImplCopyWithImpl(
      _$AccountLockedImpl _value, $Res Function(_$AccountLockedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountLockedImpl implements _AccountLocked {
  const _$AccountLockedImpl();

  @override
  String toString() {
    return 'AuthException.accountLocked()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AccountLockedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) {
    return accountLocked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) {
    return accountLocked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountLocked != null) {
      return accountLocked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) {
    return accountLocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) {
    return accountLocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountLocked != null) {
      return accountLocked(this);
    }
    return orElse();
  }
}

abstract class _AccountLocked implements AuthException {
  const factory _AccountLocked() = _$AccountLockedImpl;
}

/// @nodoc
abstract class _$$AccountExpiredImplCopyWith<$Res> {
  factory _$$AccountExpiredImplCopyWith(_$AccountExpiredImpl value,
          $Res Function(_$AccountExpiredImpl) then) =
      __$$AccountExpiredImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountExpiredImplCopyWithImpl<$Res>
    extends _$AuthExceptionCopyWithImpl<$Res, _$AccountExpiredImpl>
    implements _$$AccountExpiredImplCopyWith<$Res> {
  __$$AccountExpiredImplCopyWithImpl(
      _$AccountExpiredImpl _value, $Res Function(_$AccountExpiredImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountExpiredImpl implements _AccountExpired {
  const _$AccountExpiredImpl();

  @override
  String toString() {
    return 'AuthException.accountExpired()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AccountExpiredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) {
    return accountExpired();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) {
    return accountExpired?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountExpired != null) {
      return accountExpired();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) {
    return accountExpired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) {
    return accountExpired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountExpired != null) {
      return accountExpired(this);
    }
    return orElse();
  }
}

abstract class _AccountExpired implements AuthException {
  const factory _AccountExpired() = _$AccountExpiredImpl;
}

/// @nodoc
abstract class _$$InvalidUserNameImplCopyWith<$Res> {
  factory _$$InvalidUserNameImplCopyWith(_$InvalidUserNameImpl value,
          $Res Function(_$InvalidUserNameImpl) then) =
      __$$InvalidUserNameImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidUserNameImplCopyWithImpl<$Res>
    extends _$AuthExceptionCopyWithImpl<$Res, _$InvalidUserNameImpl>
    implements _$$InvalidUserNameImplCopyWith<$Res> {
  __$$InvalidUserNameImplCopyWithImpl(
      _$InvalidUserNameImpl _value, $Res Function(_$InvalidUserNameImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidUserNameImpl implements _InvalidUserName {
  const _$InvalidUserNameImpl();

  @override
  String toString() {
    return 'AuthException.invalidUserName()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidUserNameImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) {
    return invalidUserName();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) {
    return invalidUserName?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) {
    if (invalidUserName != null) {
      return invalidUserName();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) {
    return invalidUserName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) {
    return invalidUserName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) {
    if (invalidUserName != null) {
      return invalidUserName(this);
    }
    return orElse();
  }
}

abstract class _InvalidUserName implements AuthException {
  const factory _InvalidUserName() = _$InvalidUserNameImpl;
}

/// @nodoc
abstract class _$$AccountBlockedImplCopyWith<$Res> {
  factory _$$AccountBlockedImplCopyWith(_$AccountBlockedImpl value,
          $Res Function(_$AccountBlockedImpl) then) =
      __$$AccountBlockedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountBlockedImplCopyWithImpl<$Res>
    extends _$AuthExceptionCopyWithImpl<$Res, _$AccountBlockedImpl>
    implements _$$AccountBlockedImplCopyWith<$Res> {
  __$$AccountBlockedImplCopyWithImpl(
      _$AccountBlockedImpl _value, $Res Function(_$AccountBlockedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountBlockedImpl implements _AccountBlocked {
  const _$AccountBlockedImpl();

  @override
  String toString() {
    return 'AuthException.accountBlocked()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AccountBlockedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmailAndPasswordCombination,
    required TResult Function() accountLocked,
    required TResult Function() accountExpired,
    required TResult Function() invalidUserName,
    required TResult Function() accountBlocked,
  }) {
    return accountBlocked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidEmailAndPasswordCombination,
    TResult? Function()? accountLocked,
    TResult? Function()? accountExpired,
    TResult? Function()? invalidUserName,
    TResult? Function()? accountBlocked,
  }) {
    return accountBlocked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmailAndPasswordCombination,
    TResult Function()? accountLocked,
    TResult Function()? accountExpired,
    TResult Function()? invalidUserName,
    TResult Function()? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountBlocked != null) {
      return accountBlocked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidEmailAndPasswordCombination,
    required TResult Function(_AccountLocked value) accountLocked,
    required TResult Function(_AccountExpired value) accountExpired,
    required TResult Function(_InvalidUserName value) invalidUserName,
    required TResult Function(_AccountBlocked value) accountBlocked,
  }) {
    return accountBlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult? Function(_AccountLocked value)? accountLocked,
    TResult? Function(_AccountExpired value)? accountExpired,
    TResult? Function(_InvalidUserName value)? invalidUserName,
    TResult? Function(_AccountBlocked value)? accountBlocked,
  }) {
    return accountBlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidEmailAndPasswordCombination,
    TResult Function(_AccountLocked value)? accountLocked,
    TResult Function(_AccountExpired value)? accountExpired,
    TResult Function(_InvalidUserName value)? invalidUserName,
    TResult Function(_AccountBlocked value)? accountBlocked,
    required TResult orElse(),
  }) {
    if (accountBlocked != null) {
      return accountBlocked(this);
    }
    return orElse();
  }
}

abstract class _AccountBlocked implements AuthException {
  const factory _AccountBlocked() = _$AccountBlockedImpl;
}
